{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tfjs_1 = require(\"@tensorflow/tfjs\");\nvar fs = require(\"fs\");\nvar util_1 = require(\"util\");\nvar nodejs_kernel_backend_1 = require(\"./nodejs_kernel_backend\");\nvar readFile = util_1.promisify(fs.readFile);\n// tslint:disable-next-line:no-require-imports\nvar messages = require('./proto/api_pb');\nvar SAVED_MODEL_FILE_NAME = '/saved_model.pb';\nvar SAVED_MODEL_INIT_OP_KEY = '__saved_model_init_op';\n// This map is used to keep track of loaded SavedModel metagraph mapping\n// information. The map key is TFSavedModel id in JavaScript, value is\n// an object of path to the SavedModel, metagraph tags, and loaded Session ID in\n// the c++ bindings. When user loads a SavedModel signature, it will go through\n// entries in this map to find if the corresponding SavedModel session has\n// already been loaded in C++ addon and will reuse it if existing.\nvar loadedSavedModelPathMap = new Map();\n// The ID of loaded TFSavedModel. This ID is used to keep track of loaded\n// TFSavedModel, so the loaded session in c++ bindings for the corresponding\n// TFSavedModel can be properly reused/disposed.\nvar nextTFSavedModelId = 0;\n/**\n * Get a key in an object by its value. This is used to get protobuf enum value\n * from index.\n *\n * @param object\n * @param value\n */\n// tslint:disable-next-line:no-any\nfunction getEnumKeyFromValue(object, value) {\n  return Object.keys(object).find(function (key) {\n    return object[key] === value;\n  });\n}\nexports.getEnumKeyFromValue = getEnumKeyFromValue;\n/**\n * Read SavedModel proto message from path.\n *\n * @param path Path to SavedModel folder.\n */\nfunction readSavedModelProto(path) {\n  return __awaiter(this, void 0, void 0, function () {\n    var modelFile, array;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          // Load the SavedModel pb file and deserialize it into message.\n          try {\n            fs.accessSync(path + SAVED_MODEL_FILE_NAME, fs.constants.R_OK);\n          } catch (error) {\n            throw new Error('There is no saved_model.pb file in the directory: ' + path);\n          }\n          return [4 /*yield*/, readFile(path + SAVED_MODEL_FILE_NAME)];\n        case 1:\n          modelFile = _a.sent();\n          array = new Uint8Array(modelFile);\n          return [2 /*return*/, messages.SavedModel.deserializeBinary(array)];\n      }\n    });\n  });\n}\nexports.readSavedModelProto = readSavedModelProto;\n/**\n * Inspect the MetaGraphs of the SavedModel from the provided path. This\n * function will return an array of `MetaGraphInfo` objects.\n *\n * @param path Path to SavedModel folder.\n *\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nfunction getMetaGraphsFromSavedModel(path) {\n  return __awaiter(this, void 0, void 0, function () {\n    var result, modelMessage, metaGraphList, i, metaGraph, tags, signatureDef, signatureDefMap, signatureDefKeys, key, signatureDefEntry, inputsMapMessage, inputsMapKeys, inputs, inputsMapKey, inputTensor, inputTensorInfo, dtype, outputsMapMessage, outputsMapKeys, outputs, outputsMapKey, outputTensor, outputTensorInfo, dtype;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          result = [];\n          return [4 /*yield*/, readSavedModelProto(path)];\n        case 1:\n          modelMessage = _a.sent();\n          metaGraphList = modelMessage.getMetaGraphsList();\n          for (i = 0; i < metaGraphList.length; i++) {\n            metaGraph = {};\n            tags = metaGraphList[i].getMetaInfoDef().getTagsList();\n            metaGraph.tags = tags;\n            signatureDef = {};\n            signatureDefMap = metaGraphList[i].getSignatureDefMap();\n            signatureDefKeys = signatureDefMap.keys();\n            // Go through all signatureDefs\n            while (true) {\n              key = signatureDefKeys.next();\n              if (key.done) {\n                break;\n              }\n              // Skip TensorFlow internal Signature '__saved_model_init_op'.\n              if (key.value === SAVED_MODEL_INIT_OP_KEY) {\n                continue;\n              }\n              signatureDefEntry = signatureDefMap.get(key.value);\n              inputsMapMessage = signatureDefEntry.getInputsMap();\n              inputsMapKeys = inputsMapMessage.keys();\n              inputs = {};\n              while (true) {\n                inputsMapKey = inputsMapKeys.next();\n                if (inputsMapKey.done) {\n                  break;\n                }\n                inputTensor = inputsMapMessage.get(inputsMapKey.value);\n                inputTensorInfo = {};\n                dtype = getEnumKeyFromValue(messages.DataType, inputTensor.getDtype());\n                inputTensorInfo.dtype = mapTFDtypeToJSDtype(dtype);\n                inputTensorInfo.tfDtype = dtype;\n                inputTensorInfo.name = inputTensor.getName();\n                inputTensorInfo.shape = inputTensor.getTensorShape().getDimList();\n                inputs[inputsMapKey.value] = inputTensorInfo;\n              }\n              outputsMapMessage = signatureDefEntry.getOutputsMap();\n              outputsMapKeys = outputsMapMessage.keys();\n              outputs = {};\n              while (true) {\n                outputsMapKey = outputsMapKeys.next();\n                if (outputsMapKey.done) {\n                  break;\n                }\n                outputTensor = outputsMapMessage.get(outputsMapKey.value);\n                outputTensorInfo = {};\n                dtype = getEnumKeyFromValue(messages.DataType, outputTensor.getDtype());\n                outputTensorInfo.dtype = mapTFDtypeToJSDtype(dtype);\n                outputTensorInfo.tfDtype = dtype;\n                outputTensorInfo.name = outputTensor.getName();\n                outputTensorInfo.shape = outputTensor.getTensorShape().getDimList();\n                outputs[outputsMapKey.value] = outputTensorInfo;\n              }\n              signatureDef[key.value] = {\n                inputs: inputs,\n                outputs: outputs\n              };\n            }\n            metaGraph.signatureDefs = signatureDef;\n            result.push(metaGraph);\n          }\n          return [2 /*return*/, result];\n      }\n    });\n  });\n}\nexports.getMetaGraphsFromSavedModel = getMetaGraphsFromSavedModel;\n/**\n * Get SignatureDefEntry from SavedModel metagraphs info. The SignatureDefEntry\n * will be used when executing a SavedModel signature.\n *\n * @param savedModelInfo The MetaGraphInfo array loaded through\n *     getMetaGraphsFromSavedModel().\n * @param tags The tags of the MetaGraph to get input/output node names from.\n * @param signature The signature to get input/output node names from.\n */\nfunction getSignatureDefEntryFromMetaGraphInfo(savedModelInfo, tags, signature) {\n  for (var i = 0; i < savedModelInfo.length; i++) {\n    var metaGraphInfo = savedModelInfo[i];\n    if (stringArraysHaveSameElements(tags, metaGraphInfo.tags)) {\n      if (metaGraphInfo.signatureDefs[signature] == null) {\n        throw new Error('The SavedModel does not have signature: ' + signature);\n      }\n      return metaGraphInfo.signatureDefs[signature];\n    }\n  }\n  throw new Error(\"The SavedModel does not have tags: \" + tags);\n}\nexports.getSignatureDefEntryFromMetaGraphInfo = getSignatureDefEntryFromMetaGraphInfo;\n/**\n * A `tf.TFSavedModel` is a signature loaded from a SavedModel\n * metagraph, and allows inference execution.\n *\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nvar TFSavedModel = /** @class */function () {\n  function TFSavedModel(sessionId, jsid, signature, backend) {\n    this.sessionId = sessionId;\n    this.jsid = jsid;\n    this.signature = signature;\n    this.backend = backend;\n    this.disposed = false;\n  }\n  Object.defineProperty(TFSavedModel.prototype, \"inputs\", {\n    /**\n     * Return the array of input tensor info.\n     *\n     * @doc {heading: 'Models', subheading: 'SavedModel'}\n     */\n    get: function () {\n      var entries = this.signature.inputs;\n      var results = Object.keys(entries).map(function (key) {\n        return entries[key];\n      });\n      results.forEach(function (info) {\n        info.name = info.name.replace(/:0$/, '');\n      });\n      return results;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TFSavedModel.prototype, \"outputs\", {\n    /**\n     * Return the array of output tensor info.\n     *\n     * @doc {heading: 'Models', subheading: 'SavedModel'}\n     */\n    get: function () {\n      var entries = this.signature.outputs;\n      var results = Object.keys(entries).map(function (key) {\n        return entries[key];\n      });\n      results.forEach(function (info) {\n        info.name = info.name.replace(/:0$/, '');\n      });\n      return results;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Delete the SavedModel from nodeBackend and delete corresponding session in\n   * the C++ backend if the session is only used by this TFSavedModel.\n   *\n   * @doc {heading: 'Models', subheading: 'SavedModel'}\n   */\n  TFSavedModel.prototype.dispose = function () {\n    if (!this.disposed) {\n      this.disposed = true;\n      loadedSavedModelPathMap.delete(this.jsid);\n      for (var _i = 0, _a = Array.from(loadedSavedModelPathMap.keys()); _i < _a.length; _i++) {\n        var id = _a[_i];\n        var value = loadedSavedModelPathMap.get(id);\n        if (value.sessionId === this.sessionId) {\n          return;\n        }\n      }\n      this.backend.deleteSavedModel(this.sessionId);\n    } else {\n      throw new Error('This SavedModel has already been deleted.');\n    }\n  };\n  Object.defineProperty(TFSavedModel.prototype, \"outputNodeNames\", {\n    get: function () {\n      var _this = this;\n      if (this.outputNodeNames_ != null) {\n        return this.outputNodeNames_;\n      }\n      this.outputNodeNames_ = Object.keys(this.signature.outputs).reduce(function (names, key) {\n        names[key] = _this.signature.outputs[key].name;\n        return names;\n      }, {});\n      return this.outputNodeNames_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Execute the inference for the input tensors.\n   *\n   * @param input The input tensors, when there is single input for the model,\n   * inputs param should be a Tensor. For models with multiple inputs, inputs\n   * params should be in either Tensor[] if the input order is fixed, or\n   * otherwise NamedTensorMap format. The keys in the NamedTensorMap are the\n   * name of input tensors in SavedModel signatureDef. It can be found through\n   * `tf.node.getMetaGraphsFromSavedModel()`.\n   *\n   * For batch inference execution, the tensors for each input need to be\n   * concatenated together. For example with mobilenet, the required input shape\n   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].\n   * If we are provide a batched data of 100 images, the input tensor should be\n   * in the shape of [100, 244, 244, 3].\n   *\n   * @param config Prediction configuration for specifying the batch size.\n   *\n   * @returns Inference result tensors. The output would be single Tensor if\n   * model has single output node, otherwise Tensor[] or NamedTensorMap[] will\n   * be returned for model with multiple outputs.\n   *\n   * @doc {heading: 'Models', subheading: 'SavedModel'}\n   */\n  TFSavedModel.prototype.predict = function (inputs, config) {\n    var _this = this;\n    if (this.disposed) {\n      throw new Error('The TFSavedModel has already been deleted!');\n    } else {\n      var inputTensors = [];\n      if (inputs instanceof tfjs_1.Tensor) {\n        inputTensors.push(inputs);\n        var result = this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.signature.inputs), Object.values(this.outputNodeNames));\n        return result.length > 1 ? result : result[0];\n      } else if (Array.isArray(inputs)) {\n        inputTensors = inputs;\n        return this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.signature.inputs), Object.values(this.outputNodeNames));\n      } else {\n        var inputTensorNames = Object.keys(this.signature.inputs);\n        var providedInputNames = Object.keys(inputs);\n        if (!stringArraysHaveSameElements(inputTensorNames, providedInputNames)) {\n          throw new Error(\"The model signatureDef input names are \" + inputTensorNames.join() + \", however the provided input names are \" + providedInputNames.join() + \".\");\n        }\n        var inputNodeNamesArray = [];\n        for (var i = 0; i < inputTensorNames.length; i++) {\n          inputTensors.push(inputs[inputTensorNames[i]]);\n          inputNodeNamesArray.push(this.signature.inputs[inputTensorNames[i]]);\n        }\n        var outputTensorNames = Object.keys(this.outputNodeNames);\n        var outputNodeNamesArray = [];\n        for (var i = 0; i < outputTensorNames.length; i++) {\n          outputNodeNamesArray.push(this.outputNodeNames[outputTensorNames[i]]);\n        }\n        var outputTensors_1 = this.backend.runSavedModel(this.sessionId, inputTensors, inputNodeNamesArray, outputNodeNamesArray);\n        tfjs_1.util.assert(outputTensors_1.length === outputNodeNamesArray.length, function () {\n          return 'Output tensors do not match output node names, ' + (\"receive \" + outputTensors_1.length + \") output tensors but \") + (\"there are \" + _this.outputNodeNames.length + \" output nodes.\");\n        });\n        var outputMap = {};\n        for (var i = 0; i < outputTensorNames.length; i++) {\n          outputMap[outputTensorNames[i]] = outputTensors_1[i];\n        }\n        return outputMap;\n      }\n    }\n  };\n  /**\n   * Execute the inference for the input tensors and return activation\n   * values for specified output node names without batching.\n   *\n   * @param input The input tensors, when there is single input for the model,\n   * inputs param should be a Tensor. For models with multiple inputs, inputs\n   * params should be in either Tensor[] if the input order is fixed, or\n   * otherwise NamedTensorMap format.\n   *\n   * @param outputs string|string[]. List of output node names to retrieve\n   * activation from.\n   *\n   * @returns Activation values for the output nodes result tensors. The return\n   * type matches specified parameter outputs type. The output would be single\n   * Tensor if single output is specified, otherwise Tensor[] for multiple\n   * outputs.\n   *\n   * @doc {heading: 'Models', subheading: 'SavedModel'}\n   */\n  TFSavedModel.prototype.execute = function (inputs, outputs) {\n    throw new Error('execute() of TFSavedModel is not supported yet.');\n  };\n  return TFSavedModel;\n}();\nexports.TFSavedModel = TFSavedModel;\n/**\n * Load a TensorFlow SavedModel from disk. TensorFlow SavedModel is different\n * from TensorFlow.js model format. A SavedModel is a directory containing\n * serialized signatures and the states needed to run them. The directory has a\n * saved_model.pb (or saved_model.pbtxt) file storing the actual TensorFlow\n * program, or model, and a set of named signatures, each identifying a\n * function. The directory also has a variables directory contains a standard\n * training checkpoint. The directory may also has a assets directory contains\n * files used by the TensorFlow graph, for example text files used to initialize\n * vocabulary tables. These are supported datatypes: float32, int32, complex64,\n * string.For more information, see this guide:\n * https://www.tensorflow.org/guide/saved_model.\n *\n * @param path The path to the SavedModel.\n * @param tags The tags of the MetaGraph to load. The available tags of a\n *     SavedModel can be retrieved through tf.node.getMetaGraphsFromSavedModel()\n *     API. Defaults to ['serve'].\n * @param signature The name of the SignatureDef to load. The available\n *     SignatureDefs of a SavedModel can be retrieved through\n *     tf.node.getMetaGraphsFromSavedModel() API. Defaults to 'serving_default'.\n *\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nfunction loadSavedModel(path, tags, signature) {\n  if (tags === void 0) {\n    tags = ['serve'];\n  }\n  if (signature === void 0) {\n    signature = 'serving_default';\n  }\n  return __awaiter(this, void 0, void 0, function () {\n    var backend, savedModelInfo, signatureDefEntry, sessionId, _i, _a, id_1, modelInfo, tagsString, id, savedModel;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          nodejs_kernel_backend_1.ensureTensorflowBackend();\n          backend = nodejs_kernel_backend_1.nodeBackend();\n          return [4 /*yield*/, getMetaGraphsFromSavedModel(path)];\n        case 1:\n          savedModelInfo = _b.sent();\n          signatureDefEntry = getSignatureDefEntryFromMetaGraphInfo(savedModelInfo, tags, signature);\n          for (_i = 0, _a = Array.from(loadedSavedModelPathMap.keys()); _i < _a.length; _i++) {\n            id_1 = _a[_i];\n            modelInfo = loadedSavedModelPathMap.get(id_1);\n            if (modelInfo.path === path && stringArraysHaveSameElements(modelInfo.tags, tags)) {\n              sessionId = modelInfo.sessionId;\n            }\n          }\n          if (sessionId == null) {\n            tagsString = tags.join(',');\n            sessionId = backend.loadSavedModelMetaGraph(path, tagsString);\n          }\n          id = nextTFSavedModelId++;\n          savedModel = new TFSavedModel(sessionId, id, signatureDefEntry, backend);\n          loadedSavedModelPathMap.set(id, {\n            path: path,\n            tags: tags,\n            sessionId: sessionId\n          });\n          return [2 /*return*/, savedModel];\n      }\n    });\n  });\n}\nexports.loadSavedModel = loadSavedModel;\n/**\n * Compare if two unsorted arrays of string have the same elements.\n * @param arrayA\n * @param arrayB\n */\nfunction stringArraysHaveSameElements(arrayA, arrayB) {\n  if (arrayA.length === arrayB.length && arrayA.sort().join() === arrayB.sort().join()) {\n    return true;\n  }\n  return false;\n}\nfunction mapTFDtypeToJSDtype(tfDtype) {\n  switch (tfDtype) {\n    case 'DT_FLOAT':\n      return 'float32';\n    case 'DT_INT64':\n    case 'DT_INT32':\n    case 'DT_UINT8':\n      return 'int32';\n    case 'DT_BOOL':\n      return 'bool';\n    case 'DT_COMPLEX64':\n      return 'complex64';\n    case 'DT_STRING':\n      return 'string';\n    default:\n      throw new Error('Unsupported tensor DataType: ' + tfDtype + ', try to modify the model in python to convert the datatype');\n  }\n}\nfunction getNumOfSavedModels() {\n  nodejs_kernel_backend_1.ensureTensorflowBackend();\n  var backend = nodejs_kernel_backend_1.nodeBackend();\n  return backend.getNumOfSavedModels();\n}\nexports.getNumOfSavedModels = getNumOfSavedModels;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","Object","defineProperty","exports","tfjs_1","require","fs","util_1","nodejs_kernel_backend_1","readFile","promisify","messages","SAVED_MODEL_FILE_NAME","SAVED_MODEL_INIT_OP_KEY","loadedSavedModelPathMap","Map","nextTFSavedModelId","getEnumKeyFromValue","object","keys","find","key","readSavedModelProto","path","modelFile","array","_a","accessSync","constants","R_OK","error","Error","Uint8Array","SavedModel","deserializeBinary","getMetaGraphsFromSavedModel","modelMessage","metaGraphList","i","metaGraph","tags","signatureDef","signatureDefMap","signatureDefKeys","signatureDefEntry","inputsMapMessage","inputsMapKeys","inputs","inputsMapKey","inputTensor","inputTensorInfo","dtype","outputsMapMessage","outputsMapKeys","outputs","outputsMapKey","outputTensor","outputTensorInfo","getMetaGraphsList","getMetaInfoDef","getTagsList","getSignatureDefMap","get","getInputsMap","DataType","getDtype","mapTFDtypeToJSDtype","tfDtype","name","getName","shape","getTensorShape","getDimList","getOutputsMap","signatureDefs","getSignatureDefEntryFromMetaGraphInfo","savedModelInfo","signature","metaGraphInfo","stringArraysHaveSameElements","TFSavedModel","sessionId","jsid","backend","disposed","prototype","entries","results","map","forEach","info","replace","enumerable","configurable","dispose","delete","_i","Array","from","id","deleteSavedModel","_this","outputNodeNames_","reduce","names","predict","config","inputTensors","Tensor","runSavedModel","values","outputNodeNames","isArray","inputTensorNames","providedInputNames","join","inputNodeNamesArray","outputTensorNames","outputNodeNamesArray","outputTensors_1","util","assert","outputMap","execute","loadSavedModel","id_1","modelInfo","tagsString","savedModel","_b","ensureTensorflowBackend","nodeBackend","loadSavedModelMetaGraph","set","arrayA","arrayB","sort","getNumOfSavedModels"],"sources":["C:/Users/ACER/node_modules/@tensorflow/tfjs-node/dist/saved_model.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfjs_1 = require(\"@tensorflow/tfjs\");\nvar fs = require(\"fs\");\nvar util_1 = require(\"util\");\nvar nodejs_kernel_backend_1 = require(\"./nodejs_kernel_backend\");\nvar readFile = util_1.promisify(fs.readFile);\n// tslint:disable-next-line:no-require-imports\nvar messages = require('./proto/api_pb');\nvar SAVED_MODEL_FILE_NAME = '/saved_model.pb';\nvar SAVED_MODEL_INIT_OP_KEY = '__saved_model_init_op';\n// This map is used to keep track of loaded SavedModel metagraph mapping\n// information. The map key is TFSavedModel id in JavaScript, value is\n// an object of path to the SavedModel, metagraph tags, and loaded Session ID in\n// the c++ bindings. When user loads a SavedModel signature, it will go through\n// entries in this map to find if the corresponding SavedModel session has\n// already been loaded in C++ addon and will reuse it if existing.\nvar loadedSavedModelPathMap = new Map();\n// The ID of loaded TFSavedModel. This ID is used to keep track of loaded\n// TFSavedModel, so the loaded session in c++ bindings for the corresponding\n// TFSavedModel can be properly reused/disposed.\nvar nextTFSavedModelId = 0;\n/**\n * Get a key in an object by its value. This is used to get protobuf enum value\n * from index.\n *\n * @param object\n * @param value\n */\n// tslint:disable-next-line:no-any\nfunction getEnumKeyFromValue(object, value) {\n    return Object.keys(object).find(function (key) { return object[key] === value; });\n}\nexports.getEnumKeyFromValue = getEnumKeyFromValue;\n/**\n * Read SavedModel proto message from path.\n *\n * @param path Path to SavedModel folder.\n */\nfunction readSavedModelProto(path) {\n    return __awaiter(this, void 0, void 0, function () {\n        var modelFile, array;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    // Load the SavedModel pb file and deserialize it into message.\n                    try {\n                        fs.accessSync(path + SAVED_MODEL_FILE_NAME, fs.constants.R_OK);\n                    }\n                    catch (error) {\n                        throw new Error('There is no saved_model.pb file in the directory: ' + path);\n                    }\n                    return [4 /*yield*/, readFile(path + SAVED_MODEL_FILE_NAME)];\n                case 1:\n                    modelFile = _a.sent();\n                    array = new Uint8Array(modelFile);\n                    return [2 /*return*/, messages.SavedModel.deserializeBinary(array)];\n            }\n        });\n    });\n}\nexports.readSavedModelProto = readSavedModelProto;\n/**\n * Inspect the MetaGraphs of the SavedModel from the provided path. This\n * function will return an array of `MetaGraphInfo` objects.\n *\n * @param path Path to SavedModel folder.\n *\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nfunction getMetaGraphsFromSavedModel(path) {\n    return __awaiter(this, void 0, void 0, function () {\n        var result, modelMessage, metaGraphList, i, metaGraph, tags, signatureDef, signatureDefMap, signatureDefKeys, key, signatureDefEntry, inputsMapMessage, inputsMapKeys, inputs, inputsMapKey, inputTensor, inputTensorInfo, dtype, outputsMapMessage, outputsMapKeys, outputs, outputsMapKey, outputTensor, outputTensorInfo, dtype;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    result = [];\n                    return [4 /*yield*/, readSavedModelProto(path)];\n                case 1:\n                    modelMessage = _a.sent();\n                    metaGraphList = modelMessage.getMetaGraphsList();\n                    for (i = 0; i < metaGraphList.length; i++) {\n                        metaGraph = {};\n                        tags = metaGraphList[i].getMetaInfoDef().getTagsList();\n                        metaGraph.tags = tags;\n                        signatureDef = {};\n                        signatureDefMap = metaGraphList[i].getSignatureDefMap();\n                        signatureDefKeys = signatureDefMap.keys();\n                        // Go through all signatureDefs\n                        while (true) {\n                            key = signatureDefKeys.next();\n                            if (key.done) {\n                                break;\n                            }\n                            // Skip TensorFlow internal Signature '__saved_model_init_op'.\n                            if (key.value === SAVED_MODEL_INIT_OP_KEY) {\n                                continue;\n                            }\n                            signatureDefEntry = signatureDefMap.get(key.value);\n                            inputsMapMessage = signatureDefEntry.getInputsMap();\n                            inputsMapKeys = inputsMapMessage.keys();\n                            inputs = {};\n                            while (true) {\n                                inputsMapKey = inputsMapKeys.next();\n                                if (inputsMapKey.done) {\n                                    break;\n                                }\n                                inputTensor = inputsMapMessage.get(inputsMapKey.value);\n                                inputTensorInfo = {};\n                                dtype = getEnumKeyFromValue(messages.DataType, inputTensor.getDtype());\n                                inputTensorInfo.dtype = mapTFDtypeToJSDtype(dtype);\n                                inputTensorInfo.tfDtype = dtype;\n                                inputTensorInfo.name = inputTensor.getName();\n                                inputTensorInfo.shape = inputTensor.getTensorShape().getDimList();\n                                inputs[inputsMapKey.value] = inputTensorInfo;\n                            }\n                            outputsMapMessage = signatureDefEntry.getOutputsMap();\n                            outputsMapKeys = outputsMapMessage.keys();\n                            outputs = {};\n                            while (true) {\n                                outputsMapKey = outputsMapKeys.next();\n                                if (outputsMapKey.done) {\n                                    break;\n                                }\n                                outputTensor = outputsMapMessage.get(outputsMapKey.value);\n                                outputTensorInfo = {};\n                                dtype = getEnumKeyFromValue(messages.DataType, outputTensor.getDtype());\n                                outputTensorInfo.dtype = mapTFDtypeToJSDtype(dtype);\n                                outputTensorInfo.tfDtype = dtype;\n                                outputTensorInfo.name = outputTensor.getName();\n                                outputTensorInfo.shape = outputTensor.getTensorShape().getDimList();\n                                outputs[outputsMapKey.value] = outputTensorInfo;\n                            }\n                            signatureDef[key.value] = { inputs: inputs, outputs: outputs };\n                        }\n                        metaGraph.signatureDefs = signatureDef;\n                        result.push(metaGraph);\n                    }\n                    return [2 /*return*/, result];\n            }\n        });\n    });\n}\nexports.getMetaGraphsFromSavedModel = getMetaGraphsFromSavedModel;\n/**\n * Get SignatureDefEntry from SavedModel metagraphs info. The SignatureDefEntry\n * will be used when executing a SavedModel signature.\n *\n * @param savedModelInfo The MetaGraphInfo array loaded through\n *     getMetaGraphsFromSavedModel().\n * @param tags The tags of the MetaGraph to get input/output node names from.\n * @param signature The signature to get input/output node names from.\n */\nfunction getSignatureDefEntryFromMetaGraphInfo(savedModelInfo, tags, signature) {\n    for (var i = 0; i < savedModelInfo.length; i++) {\n        var metaGraphInfo = savedModelInfo[i];\n        if (stringArraysHaveSameElements(tags, metaGraphInfo.tags)) {\n            if (metaGraphInfo.signatureDefs[signature] == null) {\n                throw new Error('The SavedModel does not have signature: ' + signature);\n            }\n            return metaGraphInfo.signatureDefs[signature];\n        }\n    }\n    throw new Error(\"The SavedModel does not have tags: \" + tags);\n}\nexports.getSignatureDefEntryFromMetaGraphInfo = getSignatureDefEntryFromMetaGraphInfo;\n/**\n * A `tf.TFSavedModel` is a signature loaded from a SavedModel\n * metagraph, and allows inference execution.\n *\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nvar TFSavedModel = /** @class */ (function () {\n    function TFSavedModel(sessionId, jsid, signature, backend) {\n        this.sessionId = sessionId;\n        this.jsid = jsid;\n        this.signature = signature;\n        this.backend = backend;\n        this.disposed = false;\n    }\n    Object.defineProperty(TFSavedModel.prototype, \"inputs\", {\n        /**\n         * Return the array of input tensor info.\n         *\n         * @doc {heading: 'Models', subheading: 'SavedModel'}\n         */\n        get: function () {\n            var entries = this.signature.inputs;\n            var results = Object.keys(entries).map(function (key) { return entries[key]; });\n            results.forEach(function (info) {\n                info.name = info.name.replace(/:0$/, '');\n            });\n            return results;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TFSavedModel.prototype, \"outputs\", {\n        /**\n         * Return the array of output tensor info.\n         *\n         * @doc {heading: 'Models', subheading: 'SavedModel'}\n         */\n        get: function () {\n            var entries = this.signature.outputs;\n            var results = Object.keys(entries).map(function (key) { return entries[key]; });\n            results.forEach(function (info) {\n                info.name = info.name.replace(/:0$/, '');\n            });\n            return results;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Delete the SavedModel from nodeBackend and delete corresponding session in\n     * the C++ backend if the session is only used by this TFSavedModel.\n     *\n     * @doc {heading: 'Models', subheading: 'SavedModel'}\n     */\n    TFSavedModel.prototype.dispose = function () {\n        if (!this.disposed) {\n            this.disposed = true;\n            loadedSavedModelPathMap.delete(this.jsid);\n            for (var _i = 0, _a = Array.from(loadedSavedModelPathMap.keys()); _i < _a.length; _i++) {\n                var id = _a[_i];\n                var value = loadedSavedModelPathMap.get(id);\n                if (value.sessionId === this.sessionId) {\n                    return;\n                }\n            }\n            this.backend.deleteSavedModel(this.sessionId);\n        }\n        else {\n            throw new Error('This SavedModel has already been deleted.');\n        }\n    };\n    Object.defineProperty(TFSavedModel.prototype, \"outputNodeNames\", {\n        get: function () {\n            var _this = this;\n            if (this.outputNodeNames_ != null) {\n                return this.outputNodeNames_;\n            }\n            this.outputNodeNames_ =\n                Object.keys(this.signature.outputs)\n                    .reduce(function (names, key) {\n                    names[key] = _this.signature.outputs[key].name;\n                    return names;\n                }, {});\n            return this.outputNodeNames_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Execute the inference for the input tensors.\n     *\n     * @param input The input tensors, when there is single input for the model,\n     * inputs param should be a Tensor. For models with multiple inputs, inputs\n     * params should be in either Tensor[] if the input order is fixed, or\n     * otherwise NamedTensorMap format. The keys in the NamedTensorMap are the\n     * name of input tensors in SavedModel signatureDef. It can be found through\n     * `tf.node.getMetaGraphsFromSavedModel()`.\n     *\n     * For batch inference execution, the tensors for each input need to be\n     * concatenated together. For example with mobilenet, the required input shape\n     * is [1, 244, 244, 3], which represents the [batch, height, width, channel].\n     * If we are provide a batched data of 100 images, the input tensor should be\n     * in the shape of [100, 244, 244, 3].\n     *\n     * @param config Prediction configuration for specifying the batch size.\n     *\n     * @returns Inference result tensors. The output would be single Tensor if\n     * model has single output node, otherwise Tensor[] or NamedTensorMap[] will\n     * be returned for model with multiple outputs.\n     *\n     * @doc {heading: 'Models', subheading: 'SavedModel'}\n     */\n    TFSavedModel.prototype.predict = function (inputs, config) {\n        var _this = this;\n        if (this.disposed) {\n            throw new Error('The TFSavedModel has already been deleted!');\n        }\n        else {\n            var inputTensors = [];\n            if (inputs instanceof tfjs_1.Tensor) {\n                inputTensors.push(inputs);\n                var result = this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.signature.inputs), Object.values(this.outputNodeNames));\n                return result.length > 1 ? result : result[0];\n            }\n            else if (Array.isArray(inputs)) {\n                inputTensors = inputs;\n                return this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.signature.inputs), Object.values(this.outputNodeNames));\n            }\n            else {\n                var inputTensorNames = Object.keys(this.signature.inputs);\n                var providedInputNames = Object.keys(inputs);\n                if (!stringArraysHaveSameElements(inputTensorNames, providedInputNames)) {\n                    throw new Error(\"The model signatureDef input names are \" + inputTensorNames.join() + \", however the provided input names are \" + providedInputNames.join() + \".\");\n                }\n                var inputNodeNamesArray = [];\n                for (var i = 0; i < inputTensorNames.length; i++) {\n                    inputTensors.push(inputs[inputTensorNames[i]]);\n                    inputNodeNamesArray.push(this.signature.inputs[inputTensorNames[i]]);\n                }\n                var outputTensorNames = Object.keys(this.outputNodeNames);\n                var outputNodeNamesArray = [];\n                for (var i = 0; i < outputTensorNames.length; i++) {\n                    outputNodeNamesArray.push(this.outputNodeNames[outputTensorNames[i]]);\n                }\n                var outputTensors_1 = this.backend.runSavedModel(this.sessionId, inputTensors, inputNodeNamesArray, outputNodeNamesArray);\n                tfjs_1.util.assert(outputTensors_1.length === outputNodeNamesArray.length, function () { return 'Output tensors do not match output node names, ' +\n                    (\"receive \" + outputTensors_1.length + \") output tensors but \") +\n                    (\"there are \" + _this.outputNodeNames.length + \" output nodes.\"); });\n                var outputMap = {};\n                for (var i = 0; i < outputTensorNames.length; i++) {\n                    outputMap[outputTensorNames[i]] = outputTensors_1[i];\n                }\n                return outputMap;\n            }\n        }\n    };\n    /**\n     * Execute the inference for the input tensors and return activation\n     * values for specified output node names without batching.\n     *\n     * @param input The input tensors, when there is single input for the model,\n     * inputs param should be a Tensor. For models with multiple inputs, inputs\n     * params should be in either Tensor[] if the input order is fixed, or\n     * otherwise NamedTensorMap format.\n     *\n     * @param outputs string|string[]. List of output node names to retrieve\n     * activation from.\n     *\n     * @returns Activation values for the output nodes result tensors. The return\n     * type matches specified parameter outputs type. The output would be single\n     * Tensor if single output is specified, otherwise Tensor[] for multiple\n     * outputs.\n     *\n     * @doc {heading: 'Models', subheading: 'SavedModel'}\n     */\n    TFSavedModel.prototype.execute = function (inputs, outputs) {\n        throw new Error('execute() of TFSavedModel is not supported yet.');\n    };\n    return TFSavedModel;\n}());\nexports.TFSavedModel = TFSavedModel;\n/**\n * Load a TensorFlow SavedModel from disk. TensorFlow SavedModel is different\n * from TensorFlow.js model format. A SavedModel is a directory containing\n * serialized signatures and the states needed to run them. The directory has a\n * saved_model.pb (or saved_model.pbtxt) file storing the actual TensorFlow\n * program, or model, and a set of named signatures, each identifying a\n * function. The directory also has a variables directory contains a standard\n * training checkpoint. The directory may also has a assets directory contains\n * files used by the TensorFlow graph, for example text files used to initialize\n * vocabulary tables. These are supported datatypes: float32, int32, complex64,\n * string.For more information, see this guide:\n * https://www.tensorflow.org/guide/saved_model.\n *\n * @param path The path to the SavedModel.\n * @param tags The tags of the MetaGraph to load. The available tags of a\n *     SavedModel can be retrieved through tf.node.getMetaGraphsFromSavedModel()\n *     API. Defaults to ['serve'].\n * @param signature The name of the SignatureDef to load. The available\n *     SignatureDefs of a SavedModel can be retrieved through\n *     tf.node.getMetaGraphsFromSavedModel() API. Defaults to 'serving_default'.\n *\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nfunction loadSavedModel(path, tags, signature) {\n    if (tags === void 0) { tags = ['serve']; }\n    if (signature === void 0) { signature = 'serving_default'; }\n    return __awaiter(this, void 0, void 0, function () {\n        var backend, savedModelInfo, signatureDefEntry, sessionId, _i, _a, id_1, modelInfo, tagsString, id, savedModel;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    nodejs_kernel_backend_1.ensureTensorflowBackend();\n                    backend = nodejs_kernel_backend_1.nodeBackend();\n                    return [4 /*yield*/, getMetaGraphsFromSavedModel(path)];\n                case 1:\n                    savedModelInfo = _b.sent();\n                    signatureDefEntry = getSignatureDefEntryFromMetaGraphInfo(savedModelInfo, tags, signature);\n                    for (_i = 0, _a = Array.from(loadedSavedModelPathMap.keys()); _i < _a.length; _i++) {\n                        id_1 = _a[_i];\n                        modelInfo = loadedSavedModelPathMap.get(id_1);\n                        if (modelInfo.path === path &&\n                            stringArraysHaveSameElements(modelInfo.tags, tags)) {\n                            sessionId = modelInfo.sessionId;\n                        }\n                    }\n                    if (sessionId == null) {\n                        tagsString = tags.join(',');\n                        sessionId = backend.loadSavedModelMetaGraph(path, tagsString);\n                    }\n                    id = nextTFSavedModelId++;\n                    savedModel = new TFSavedModel(sessionId, id, signatureDefEntry, backend);\n                    loadedSavedModelPathMap.set(id, { path: path, tags: tags, sessionId: sessionId });\n                    return [2 /*return*/, savedModel];\n            }\n        });\n    });\n}\nexports.loadSavedModel = loadSavedModel;\n/**\n * Compare if two unsorted arrays of string have the same elements.\n * @param arrayA\n * @param arrayB\n */\nfunction stringArraysHaveSameElements(arrayA, arrayB) {\n    if (arrayA.length === arrayB.length &&\n        arrayA.sort().join() === arrayB.sort().join()) {\n        return true;\n    }\n    return false;\n}\nfunction mapTFDtypeToJSDtype(tfDtype) {\n    switch (tfDtype) {\n        case 'DT_FLOAT':\n            return 'float32';\n        case 'DT_INT64':\n        case 'DT_INT32':\n        case 'DT_UINT8':\n            return 'int32';\n        case 'DT_BOOL':\n            return 'bool';\n        case 'DT_COMPLEX64':\n            return 'complex64';\n        case 'DT_STRING':\n            return 'string';\n        default:\n            throw new Error('Unsupported tensor DataType: ' + tfDtype +\n                ', try to modify the model in python to convert the datatype');\n    }\n}\nfunction getNumOfSavedModels() {\n    nodejs_kernel_backend_1.ensureTensorflowBackend();\n    var backend = nodejs_kernel_backend_1.nodeBackend();\n    return backend.getNumOfSavedModels();\n}\nexports.getNumOfSavedModels = getNumOfSavedModels;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}